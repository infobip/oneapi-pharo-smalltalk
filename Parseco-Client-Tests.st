TestCase subclass: #ParsecoHttpClientTest	instanceVariableNames: 'client'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client-Tests'!!ParsecoHttpClientTest methodsFor: 'running' stamp: 'MilanMimica 9/29/2012 09:48'!setUp	client := ParsecoHttpClient new authentication: ParsecoAuthentication new! !!ParsecoHttpClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:49'!testBasicAuthorizationHeader| config |	config := ParsecoConfiguration default authType: #BASIC; username: 'luzer'; password: 'word'.	client configuration: config.	self assert: client authorizationHeader equals: 'Basic ', 'luzer:word' base64Encoded.! !!ParsecoHttpClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:48'!testIBSSOAuthorizationHeader| config |	config := ParsecoConfiguration default authType: #IBSSO; username: 'luzer'; password: 'word'.	client configuration: config.	self assert: client authorizationHeader equals: 'IBSSO '.! !TestCase subclass: #ParsecoTestObject	instanceVariableNames: 'one two tree four'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client-Tests'!!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!four	^ four! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!four: anObject	four := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!one	^ one! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!one: anObject	one := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!tree	^ tree! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!tree: anObject	tree := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!two	^ two! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!two: anObject	two := anObject! !TestCase subclass: #ParsecoClientTest	instanceVariableNames: 'smsClient'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client-Tests'!!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 9/29/2012 09:32'!exampleQueryHlr"An example of making an HLR query and receiving a HLR data as a callback to your HTTP server."| request destination server onHlrResponse ip port path |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	port := 8080.	ip := 'your-public-ip-address'.	path := '/'.	request := ParsecoHlrRequest new		notifyURL: 'http://', ip, ':', port asString, path;		address: destination. "FIXME: should allow querying multiple addresses in one request"		server := ZnServer startOn: port.	onHlrResponse := [ :httpRequest |		| hlrList |		hlrList := ParsecoHlrResponse readArray: httpRequest entity readStream.		hlrList do: [ :each | self logCr: each address, ': ', each currentRoaming ].		[ 1 second asDelay wait. server stop ] fork.		ZnResponse ok: (ZnStringEntity text: 'OK')	].	server delegate: (ZnValueDelegate with: onHlrResponse).	smsClient queryHlr: request.	smsClient close.! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 9/29/2012 09:33'!exampleQueryInbound"An example of querying for inbound messages"| inbound |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	inbound := smsClient queryInbound: 2.	smsClient close.! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 9/29/2012 09:32'!exampleSendSmsAsyncDelivery"An example of sending an SMS and receiving a delivery report as a callback.Note that this method spawns a new process, periodically invokes a HTTP request, allocates an external semaphore... It is does not scaleand uses a lot of resources. It is recommended to have the delivery report pushed to your HTTP server, if possible."| request destination |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name; address: { destination }.	smsClient send: request onDelivery: [ :deliveryInfo |		self logCr: destination, ': ', (deliveryInfo statusFor: destination) ]! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 9/29/2012 09:33'!exampleSendSmsPushDelivery"An example of sending an SMS and receiving a delivery report as a callback to your HTTP server."| request destination server onDeliveryReport ip port path |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	port := 8080.	ip := 'your-public-ip-address'.	path := '/'.	request := ParsecoSmsRequest new		message: 'Hello from Pharo!!';		notifyURL: 'http://', ip, ':', port asString, path;		senderAddress: self class name;		callbackData: 'my data'; "optional"		address: { destination }.		"You shouldn't start a new HTTP server instance for every message you send, of course."	server := ZnServer startOn: port.	onDeliveryReport := [ :httpRequest |		| deliveryInfo |		deliveryInfo := ParsecoDeliveryNotification on: httpRequest entity readStream.		self logCr: 'callbackData: ', deliveryInfo callbackData.		self logCr: deliveryInfo address, ': ', deliveryInfo status.		[ 1 second asDelay wait. server stop ] fork.		ZnResponse ok: (ZnStringEntity text: 'OK')	].	server delegate: (ZnValueDelegate with: onDeliveryReport).	smsClient send: request.	smsClient close.! !!ParsecoClientTest methodsFor: 'running' stamp: 'MilanMimica 8/23/2012 12:34'!setUp	smsClient := ParsecoClient new configuration: ParsecoConfiguration default! !!ParsecoClientTest methodsFor: 'running' stamp: 'MilanMimica 8/20/2012 21:18'!tearDown	smsClient ifNotNil: [ smsClient close ]! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/21/2012 14:56'!testFormUrlEncoded1| object res |	res := smsClient formUrlEncoded: object.	self assert: res isEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/21/2012 15:49'!testFormUrlEncoded2| object res |	object := ParsecoTestObject new one: 'one'; two: 2; tree: nil; four: {1. 2. 'a b'}.	res := smsClient formUrlEncoded: object.	self assert: res = 'one=one&two=2&tree=&four=1&four=2&four=a%20b'! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:34'!testHlrFor| hlrResponse |	hlrResponse := smsClient hlrFor: ParsecoConfiguration defaultDestination.	self assert: hlrResponse address = ParsecoConfiguration defaultDestination.	self assert: hlrResponse extended notNil! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:36'!testLoginFail| config |	config := ParsecoConfiguration default.	config password: 'no-one-has-this-password'.	config authType: #IBSSO.	smsClient configuration: config.	self should: [ smsClient login ] raise: ParsecoError whoseDescriptionIncludes: '401' description: 'Should fail with 401'.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:59'!testLoginWithCookie	smsClient configuration authType: #IBSSO.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.	self deny: smsClient configuration isBasicAuthentication.	smsClient login.	self assert: smsClient authentication token notNil.	self assert: smsClient authentication type = #IBSSO! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:59'!testLogout	smsClient configuration authType: #IBSSO.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.	self deny: smsClient configuration isBasicAuthentication.	smsClient login.	self assert: smsClient authentication token notNil.	self assert: smsClient authentication type = #IBSSO.	smsClient logout.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:37'!testQueryStatusorId| deliveryInfo requestId request senderAddress |	senderAddress := self class name.	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: senderAddress; address: { ParsecoConfiguration defaultDestination }.	requestId := smsClient send: request.	deliveryInfo := smsClient queryStatusFor: senderAddress id: requestId.		self assert: deliveryInfo notNil.	self assert: (deliveryInfo statusFor: ParsecoConfiguration defaultDestination) =  'MessageWaiting'! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:37'!testQueryStatusorIdFail| deliveryInfo senderAddress |	senderAddress := self class name.	deliveryInfo := smsClient queryStatusFor: senderAddress id: 'blah'.	self assert: deliveryInfo notNil! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:37'!testSendSms| request requestId |	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name; address: { ParsecoConfiguration defaultDestination }.	requestId := smsClient send: request.	self assert: requestId isString.	self assert: requestId notEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:37'!testSendSmsMultiple| request requestId |	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name;		address: { ParsecoConfiguration defaultDestination. ParsecoConfiguration defaultDestination }.	requestId := smsClient send: request.	self assert: requestId isString.	self assert: requestId notEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 9/29/2012 09:38'!testTimeZone"| timeZone |	timeZone := smsClient timeZone.	self assert: false"! !