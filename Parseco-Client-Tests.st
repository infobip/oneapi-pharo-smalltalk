TestCase subclass: #ParsecoTestObject	instanceVariableNames: 'one two tree four'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client-Tests'!!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!four	^ four! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!four: anObject	four := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!one	^ one! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!one: anObject	one := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!tree	^ tree! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!tree: anObject	tree := anObject! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!two	^ two! !!ParsecoTestObject methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 14:37'!two: anObject	two := anObject! !TestCase subclass: #ParsecoClientTest	instanceVariableNames: 'smsClient'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client-Tests'!!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 8/25/2012 22:04'!exampleQueryHlr"An example of making an HLR query and receiving a HLR data as a callback to your HTTP server."| request destination server onHlrResponse ip port path |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	port := 8080.	ip := 'your-public-ip-address'.	path := '/'.	request := ParsecoHlrRequest new		notifyURL: 'http://', ip, ':', port asString, path;		address: destination. "FIXME: should allow querying multiple addresses in one request"		server := ZnServer startOn: port.	onHlrResponse := [ :httpRequest |		| hlrList |		hlrList := ParsecoHlrResponse readArray: httpRequest entity readStream.		hlrList do: [ :each | self logCr: each address, ': ', each currentRoaming ].		[ 1 second asDelay wait. server stop ] fork.		ZnResponse ok: (ZnStringEntity text: 'OK')	].	server delegate: (ZnValueDelegate with: onHlrResponse).	smsClient login.	smsClient queryHlr: request.	smsClient logout.	smsClient close.! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 8/27/2012 16:24'!exampleQueryInbound"An example of querying for inbound messages"| inbound |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	smsClient login.	inbound := smsClient queryInbound: 2.	smsClient logout.	smsClient close.! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 8/27/2012 15:55'!exampleSendSmsAsyncDelivery"An example of sending an SMS and receiving a delivery report as a callback.Note that this method spawns a new process, periodically invokes a HTTP request, allocates an external semaphore... It is does not scaleand uses a lot of resources. It is recommended to have the delivery report pushed to your HTTP server, if possible."| request destination |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name; address: { destination }.		smsClient login.	smsClient send: request onDelivery: [ :deliveryInfo |		self logCr: destination, ': ', (deliveryInfo statusFor: destination) ]! !!ParsecoClientTest methodsFor: 'examples' stamp: 'MilanMimica 8/25/2012 21:48'!exampleSendSmsPushDelivery"An example of sending an SMS and receiving a delivery report as a callback to your HTTP server."| request destination server onDeliveryReport ip port path |	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	destination := ParsecoConfiguration defaultDestination.	port := 8080.	ip := 'your-public-ip-address'.	path := '/'.	request := ParsecoSmsRequest new		message: 'Hello from Pharo!!';		notifyURL: 'http://', ip, ':', port asString, path;		senderAddress: self class name;		callbackData: 'my data'; "optional"		address: { destination }.		"You shouldn't start a new HTTP server instance for every message you send, of course."	server := ZnServer startOn: port.	onDeliveryReport := [ :httpRequest |		| deliveryInfo |		deliveryInfo := ParsecoDeliveryNotification on: httpRequest entity readStream.		self logCr: 'callbackData: ', deliveryInfo callbackData.		self logCr: deliveryInfo address, ': ', deliveryInfo status.		[ 1 second asDelay wait. server stop ] fork.		ZnResponse ok: (ZnStringEntity text: 'OK')	].	server delegate: (ZnValueDelegate with: onDeliveryReport).	smsClient login.	smsClient send: request.	smsClient logout.	smsClient close.! !!ParsecoClientTest methodsFor: 'running' stamp: 'MilanMimica 8/23/2012 12:34'!setUp	smsClient := ParsecoClient new configuration: ParsecoConfiguration default! !!ParsecoClientTest methodsFor: 'running' stamp: 'MilanMimica 8/20/2012 21:18'!tearDown	smsClient ifNotNil: [ smsClient close ]! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/21/2012 14:56'!testFormUrlEncoded1| object res |	res := smsClient formUrlEncoded: object.	self assert: res isEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/21/2012 15:49'!testFormUrlEncoded2| object res |	object := ParsecoTestObject new one: 'one'; two: 2; tree: nil; four: {1. 2. 'a b'}.	res := smsClient formUrlEncoded: object.	self assert: res = 'one=one&two=2&tree=&four=1&four=2&four=a%20b'! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/24/2012 14:03'!testHlrFor| hlrResponse |	smsClient login.	hlrResponse := smsClient hlrFor: ParsecoConfiguration defaultDestination.	self assert: hlrResponse address = ParsecoConfiguration defaultDestination.	self assert: hlrResponse extended notNil! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/20/2012 21:29'!testLogin	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.	smsClient login.	self assert: smsClient authentication token notNil.	self assert: smsClient authentication type = #IBSSO! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/21/2012 13:09'!testLoginFail| config |	config := ParsecoConfiguration default password: 'no-one-has-this-password'.	smsClient configuration: config.	self should: [ smsClient login ] raise: ParsecoError whoseDescriptionIncludes: '401' description: 'Should fail with 401'.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/23/2012 12:18'!testLogout	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.	smsClient login.	self assert: smsClient authentication token notNil.	self assert: smsClient authentication type = #IBSSO.	smsClient logout.	self assert: smsClient authentication token isNil.	self assert: smsClient authentication type isNil.! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/23/2012 12:09'!testQueryStatusorId| deliveryInfo requestId request senderAddress |	senderAddress := self class name.	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: senderAddress; address: { ParsecoConfiguration defaultDestination }.	smsClient login.	requestId := smsClient send: request.	deliveryInfo := smsClient queryStatusFor: senderAddress id: requestId.		self assert: deliveryInfo notNil.	self assert: (deliveryInfo statusFor: ParsecoConfiguration defaultDestination) =  'MessageWaiting'! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/23/2012 12:09'!testQueryStatusorIdFail| deliveryInfo senderAddress |	senderAddress := self class name.	smsClient login.	deliveryInfo := smsClient queryStatusFor: senderAddress id: 'blah'.	self assert: deliveryInfo notNil! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/23/2012 12:09'!testSendSms| request requestId |	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name; address: { ParsecoConfiguration defaultDestination }.	smsClient login.	requestId := smsClient send: request.	self assert: requestId isString.	self assert: requestId notEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/23/2012 12:08'!testSendSmsMultiple| request requestId |	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: self class name;		address: { ParsecoConfiguration defaultDestination. ParsecoConfiguration defaultDestination }.	smsClient login.	requestId := smsClient send: request.	self assert: requestId isString.	self assert: requestId notEmpty! !!ParsecoClientTest methodsFor: 'tests' stamp: 'MilanMimica 8/27/2012 15:56'!testTimeZone"| timeZone |	smsClient login.	timeZone := smsClient timeZone.	smsClient logout.	self assert: false"! !