Object subclass: #ParsecoHttpClient	instanceVariableNames: 'configuration authentication client'	classVariableNames: 'LoggingEnabled Version'	poolDictionaries: ''	category: 'Parseco-Client'!!ParsecoHttpClient commentStamp: 'MilanMimica 8/25/2012 12:11' prior: 0!I wrap ZnClient into a few convenient methods. Only used internally by ParsecoClient.Instance Variables:	configuration	<ParsecoConfiguration>	authentication	<MCMockDefinition | ParsecoAuthentication | RBLiteralValueNode | RBVariableNode | SettingTokenFilter>	client	<ZnClient>!!ParsecoHttpClient methodsFor: 'http' stamp: 'MilanMimica 8/23/2012 11:08'!getFrom: aString	^ (self buildClient: aString)		get;		response.! !!ParsecoHttpClient methodsFor: 'http' stamp: 'MilanMimica 8/23/2012 11:37'!post: anEntity to: aString	^ (self buildClient: aString)		entity: anEntity;		post;		response.! !!ParsecoHttpClient methodsFor: 'http' stamp: 'MilanMimica 8/23/2012 12:18'!postTo: aString	^ (self buildClient: aString)		post;		response.! !!ParsecoHttpClient methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 20:50'!authentication: anObject	authentication := anObject! !!ParsecoHttpClient methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 20:50'!configuration: anObject	configuration := anObject! !!ParsecoHttpClient methodsFor: 'private' stamp: 'MilanMimica 8/23/2012 11:08'!buildClient: aString	^ client		host: configuration apiUrl;		path: configuration version, '/', aString;		headerAt: 'Authorization' put: configuration authType asString, String space, (authentication token ifNil: [ '' ]);		headerAt: 'User-Agent' put: 'OneApi-Smalltalk-', Version;		accept: ZnMimeType applicationJson! !!ParsecoHttpClient methodsFor: 'initialize-release' stamp: 'MilanMimica 8/20/2012 21:16'!close	client close! !!ParsecoHttpClient methodsFor: 'initialize-release' stamp: 'MilanMimica 8/23/2012 11:41'!initialize	client := ZnClient new.	LoggingEnabled ifTrue: [ client log addListener: ZnTranscriptLogger new ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoHttpClient class	instanceVariableNames: ''!!ParsecoHttpClient class methodsFor: 'options' stamp: 'MilanMimica 8/20/2012 21:58'!disableLogging	LoggingEnabled := false! !!ParsecoHttpClient class methodsFor: 'options' stamp: 'MilanMimica 8/20/2012 21:58'!enableLogging	LoggingEnabled := true! !!ParsecoHttpClient class methodsFor: 'class initialization' stamp: 'MilanMimica 8/20/2012 21:58'!initialize	Version := '1.0-pharo'.	self disableLogging! !Object subclass: #ParsecoAuthentication	instanceVariableNames: 'type ibssoToken oauthToken'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client'!!ParsecoAuthentication commentStamp: 'MilanMimica 8/25/2012 11:35' prior: 0!I hold internal authentication data for the session.!!ParsecoAuthentication methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:11'!token	^ (type = #OAUTH)		ifTrue: [ oauthToken ]		ifFalse: [ ibssoToken ]! !!ParsecoAuthentication methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:12'!token: aString	(type = #OAUTH)		ifTrue: [ oauthToken := aString ]		ifFalse: [ ibssoToken := aString ]! !!ParsecoAuthentication methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 21:30'!type	^ type! !!ParsecoAuthentication methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:13'!type: aSymbol	type := aSymbol ! !Object subclass: #ParsecoClient	instanceVariableNames: 'configuration authentication httpClient'	classVariableNames: 'CustomerProfileBaseUrl DataConnectionProfileBaseUrl SmsMessagingInboundBaseUrl SmsMessagingOutboundBaseUrl'	poolDictionaries: ''	category: 'Parseco-Client'!!ParsecoClient commentStamp: 'MilanMimica 8/27/2012 15:58' prior: 0!I am the main class of Parseco client library. I expose all Parseco functionalities through methods in categories named 'inbound', 'hlr', 'customer-profile' and 'outbound'.All actions are performed by composing one or more HTTP requests and performing them with a HTTP client towards OneAPI Parseco service. Prior to performing any action on the instance you have to login, to obtain the authentication token. Authentication token is the only object state, so the implementation is thread-safe by definition.Examples:	"Perform once to obtain aithentication token."	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	smsClient login.	"Sending an SMS:"	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: '987654321'; address: '12391000'.	smsClient send: request.		"Sending muliple SMSes and receiveing delivery reports:"	request := ParsecoSmsRequest new message: 'Hello from Pharo!!'; senderAddress: '987654321'; address: { '12391000'. '12391001'. '12391002' }.	smsClient send: request onDelivery: [ :deliveryInfo | deliveryInfo statusesDo: [ :address :status | self logCr: address, ': ', status ] ].	"Performing an HLR:"	hlrResponse := smsClient hlrFor: '12391000'.	self logCr: hlrResponse currentRoaming.		"It's always nice to clean up behind you."	smsClient logout.	smsClient close. "Closes the underlying TCP socket, which is keep open for HTTP1.1 keep-alive feature."	For more examples check out ParsecoClientTest class.	Instance Variables:	configuration	<ParsecoConfiguration> used to configure the client, supply username and password	authentication	<ParsecoAuthentication> authentication state	httpClient	<ParsecoHttpClient> HTTP client that performs HTTP requests!!ParsecoClient methodsFor: 'hlr' stamp: 'MilanMimica 8/27/2012 16:41'!hlrFor: anAddress| response |	response := httpClient getFrom: DataConnectionProfileBaseUrl, '/roamingStatus?address=', anAddress encodeForHTTP, '&includeExtendedData=true'.	^ response isSuccess		ifTrue: [ (ParsecoHlrResponse readArray: response entity readStream) first ]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'hlr' stamp: 'MilanMimica 8/27/2012 16:41'!queryHlr: aHlrRequest| response params serialized |	serialized := self formUrlEncoded: aHlrRequest.	params := serialized, '&includeExtendedData=true'.	response := httpClient getFrom: DataConnectionProfileBaseUrl, '/roamingStatus?', params.	response isSuccess ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'inbound' stamp: 'MilanMimica 8/27/2012 16:09'!queryAllInbound	^ self queryInbound: nil! !!ParsecoClient methodsFor: 'inbound' stamp: 'MilanMimica 8/27/2012 16:15'!queryInbound: maxMessageCount"Retreives a collection ParsecoInboundMessage objects."| response url |	url := SmsMessagingInboundBaseUrl, '/registrations/INBOUND/messages'.	(maxMessageCount notNil and: [ maxMessageCount positive ]) ifTrue:  [ url := url, '?maxBatchSize=', maxMessageCount asString ].	response := httpClient getFrom: url.	^ response isSuccess		ifTrue: [ ParsecoInboundMessage readArray: response entity readStream ]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'inbound' stamp: 'MilanMimica 8/27/2012 16:24'!queryOneInbound"Retreives one ParsecoInboundMessage objects, or nil if none."| result |	result := self queryInbound: 1.	^ result ifNotNil: [ result first ]! !!ParsecoClient methodsFor: 'serialization' stamp: 'MilanMimica 8/25/2012 21:50'!formUrlEncoded: anObject| separator writePair |	separator := ''.	^ String streamContents: [ :s |		writePair := [ :name :value |			s nextPutAll: separator.			separator := '&'.			s nextPutAll: name encodeForHTTP.			s nextPut: $=.			s nextPutAll: (value ifNil: ['']) asString encodeForHTTP		].		anObject class instVarNames do: [ :name |		| value |						value := anObject instVarNamed: name.			(value notNil and: [ value isCollection and: [ value isString not ] ])				ifTrue: [ value do: [ :each | writePair value: name value: each ] ]				ifFalse: [ writePair value: name value: value ]		]	]! !!ParsecoClient methodsFor: 'serialization' stamp: 'MilanMimica 8/23/2012 12:53'!parse: aClass from: aStream	^ (NeoJSONReader on: aStream)	        mapInstVarsFor: aClass;	        nextAs: aClass! !!ParsecoClient methodsFor: 'serialization' stamp: 'MilanMimica 8/20/2012 20:48'!parse: aClass from: aStream root: aSymbol	^ (NeoJSONReader on: aStream)	        mapInstVarsFor: aClass;	        for: #Wrapper customDo: [ :mapping |	                mapping reader: [ :jsonReader |				| result |                        jsonReader parseMapKeysDo: [ :key |                                key = aSymbol                                        ifTrue: [ result := jsonReader nextAs: aClass ] ].                        result ] ];	        nextAs: #Wrapper! !!ParsecoClient methodsFor: 'serialization' stamp: 'MilanMimica 8/21/2012 13:28'!write: anObject on: aStream root: aSymbol	aStream << '{ "' << aSymbol asString  << '": '.	(NeoJSONWriter on: aStream)		prettyPrint: true;		mapInstVarsFor: anObject class;		nextPut: anObject.	aStream << String cr << '} '.! !!ParsecoClient methodsFor: 'private' stamp: 'MilanMimica 8/21/2012 15:52'!handleFailure: aStringOraHttpResponse| reason error details |	reason := aStringOraHttpResponse isString		ifFalse: [			[ | parsed |				parsed := ParsecoErrorResponse on: aStringOraHttpResponse entity readStream.				details := parsed text			] on: Error do: [ ].			String streamContents: [ :s | aStringOraHttpResponse statusLine printCodeAndReasonOn: s ]].	error := ParsecoError new.	error messageText: reason.	error details: details.	error signal! !!ParsecoClient methodsFor: 'customer-profile' stamp: 'MilanMimica 8/23/2012 12:30'!login"Obtains an token that is used to authenticate ourselves in subsequent calls to this client instance."| entity loginResponse response |	authentication token: nil.	authentication type: nil.	entity := ZnApplicationFormUrlEncodedEntity withAll: (		Dictionary newFrom: {			'username' -> configuration username.			'password' -> configuration password }).	response := httpClient post: entity to: CustomerProfileBaseUrl, '/login'.	response isSuccess		ifTrue: [			loginResponse := self parse: ParsecoLoginResponse from: response entity readStream root: #login.			loginResponse verified ifFalse: [ self handleFailure: 'Login failed: not verified' ].			authentication token: loginResponse ibAuthCookie.			authentication type: configuration authType		]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'customer-profile' stamp: 'MilanMimica 8/23/2012 12:17'!logout| response |	response := httpClient postTo: CustomerProfileBaseUrl, '/logout'.	response isSuccess 		ifTrue: [			authentication token: nil.			authentication type: nil		]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'customer-profile' stamp: 'MilanMimica 8/27/2012 16:41'!timeZone"Obtains an ParsecoTimeZone object."| response |	response := httpClient getFrom: CustomerProfileBaseUrl, '/timeZone'.	^ response isSuccess		ifTrue: [			self parse: ParsecoTimeZone from: response entity readStream		]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'outbound' stamp: 'MilanMimica 8/23/2012 12:35'!queryStatusFor: senderAddress id: aString"Retreives a ParsecoDeliveryInfo object for a specific requestId returned by send:"| response |	response := httpClient getFrom: SmsMessagingOutboundBaseUrl, '/', senderAddress encodeForHTTP, '/requests/', aString, '/deliveryInfos'.	^ response isSuccess		ifTrue: [ ParsecoDeliveryInfo on: response entity readStream ]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'outbound' stamp: 'MilanMimica 8/24/2012 14:07'!send: aRequest| entity serialized response |	serialized := self formUrlEncoded: aRequest.	entity := (ZnStringEntity type: ZnMimeType applicationFormUrlEncoded) string: serialized.	response := httpClient post: entity to: SmsMessagingOutboundBaseUrl, '/', aRequest senderAddress encodeForHTTP, '/requests'.	^ response isCreated		ifTrue: [ (ParsecoResourceResponse on: response entity readStream) resourceId ]		ifFalse: [ self handleFailure: response ]! !!ParsecoClient methodsFor: 'outbound' stamp: 'MilanMimica 8/23/2012 12:44'!send: aRequest onDelivery: aOneArgBlock"Just like send: except it executes the callback when a delivery report is received.Note that this method spawns a new process, periodically invokes a HTTP request, allocates an external semaphore..."| requestId delivery |	requestId := self send: aRequest.	[	delivery := self waitDeliveryFor: aRequest senderAddress id: requestId.		aOneArgBlock value: delivery	] fork! !!ParsecoClient methodsFor: 'outbound' stamp: 'MilanMimica 8/23/2012 12:39'!waitDeliveryFor: aSenderAddress id: aRequestId"Retreives a ParsecoDeliveryInfo object for a specific requestId returned by send:. The returned delivery report status won't change, i.e. it represents a final status in message lifecycle."| deliveryStatus delay |	delay := configuration deliveryRetrivalInterval asDelay.	[	deliveryStatus := self queryStatusFor: aSenderAddress id: aRequestId.		deliveryStatus anySatisfy: [ :status | status = 'MessageWaiting' ]	] whileTrue: [ delay wait ].	^ deliveryStatus! !!ParsecoClient methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 20:55'!authentication	^ authentication! !!ParsecoClient methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:16'!configuration	^ configuration! !!ParsecoClient methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 20:50'!configuration: anObject	configuration := anObject.	httpClient configuration: configuration! !!ParsecoClient methodsFor: 'initialize-release' stamp: 'MilanMimica 8/23/2012 12:32'!close"You can call this to explicitly close the underlaying TCP socket which is kept open for possible eventual HTTP invocatinos (HTTP1.1 keep-alive)."	httpClient close! !!ParsecoClient methodsFor: 'initialize-release' stamp: 'MilanMimica 8/20/2012 20:50'!initialize	authentication := ParsecoAuthentication new.	httpClient := ParsecoHttpClient new authentication: authentication! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoClient class	instanceVariableNames: ''!!ParsecoClient class methodsFor: 'class initialization' stamp: 'MilanMimica 8/24/2012 14:43'!initialize	super initialize.	CustomerProfileBaseUrl  := 'customerProfile'.	SmsMessagingOutboundBaseUrl := 'smsmessaging/outbound'.	SmsMessagingInboundBaseUrl := 'smsmessaging/inbound'.	DataConnectionProfileBaseUrl := 'terminalstatus/queries'! !Object subclass: #ParsecoConfiguration	instanceVariableNames: 'apiUrl version username password authType deliveryRetrivalInterval'	classVariableNames: 'DefaultApiUrl DefaultAuthType DefaultDeliveryRetrivalInterval DefaultDestination DefaultPassword DefaultUsername DefaultVersion'	poolDictionaries: ''	category: 'Parseco-Client'!!ParsecoConfiguration commentStamp: 'MilanMimica 8/25/2012 12:11' prior: 0!Pass an instance of me to ParsecoClient.It is recomended to modify ParsecoConfiguration class >> setDefaults and use ParsecoConfiguration class >> default to obtain an instance.Usage:	smsClient := ParsecoClient new configuration: ParsecoConfiguration default.	smsClient login.	...Instance Variables:	apiUrl	<ProtoObject>	version	<ProtoObject>	username	<ProtoObject>	password	<ProtoObject>	authType	<ProtoObject>	deliveryRetrivalInterval	<ProtoObject>!!ParsecoConfiguration methodsFor: 'initialize-release' stamp: 'MilanMimica 8/23/2012 11:54'!default	apiUrl := DefaultApiUrl.	version := DefaultVersion.	authType := DefaultAuthType.	username := DefaultUsername.	password := DefaultPassword.	deliveryRetrivalInterval := DefaultDeliveryRetrivalInterval	! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!apiUrl	^ apiUrl! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!apiUrl: anObject	apiUrl := anObject! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:13'!authType	^ authType! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:13'!authType: anObject	authType := anObject! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 11:52'!deliveryRetrivalInterval	^ deliveryRetrivalInterval! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 11:52'!deliveryRetrivalInterval: anObject	deliveryRetrivalInterval := anObject! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!password	^ password! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!password: anObject	password := anObject! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!username	^ username! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!username: anObject	username := anObject! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!version	^ version! !!ParsecoConfiguration methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:10'!version: anObject	version := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoConfiguration class	instanceVariableNames: ''!!ParsecoConfiguration class methodsFor: 'instance creation' stamp: 'MilanMimica 8/20/2012 16:05'!default	^ self new default! !!ParsecoConfiguration class methodsFor: 'class initialization' stamp: 'MilanMimica 8/20/2012 16:09'!initialize 	super initialize.	self setDefaults! !!ParsecoConfiguration class methodsFor: 'class initialization' stamp: 'MilanMimica 8/28/2012 11:50'!setDefaults"Change this defaults to point to your own parseco acount. "	DefaultUsername := 'your-username'.	DefaultPassword := 'your-password'.	DefaultDestination := '385911231234'. "used by unit tests as a destination""The following is the best to keep at these predefined defaults."	DefaultApiUrl := 'api.parseco.com'.	DefaultVersion := '1'.	DefaultAuthType := #IBSSO.	DefaultDeliveryRetrivalInterval := 5 seconds! !!ParsecoConfiguration class methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 15:12'!defaultDestination	^ DefaultDestination! !Error subclass: #ParsecoError	instanceVariableNames: 'details'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Client'!!ParsecoError commentStamp: 'MilanMimica 8/25/2012 11:59' prior: 0!I represent a common Exception for all Parseco-related errors.Instance Variables:	details	- aString holding detailed information about the error (optional)!!ParsecoError methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 12:36'!details	^ details! !!ParsecoError methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 12:36'!details: anObject	details := anObject! !ParsecoHttpClient initialize!ParsecoClient initialize!ParsecoConfiguration initialize!