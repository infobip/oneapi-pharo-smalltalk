Object subclass: #ParsecoJsonResponse	instanceVariableNames: 'tree'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoJsonResponse commentStamp: 'MilanMimica 8/24/2012 11:55' prior: 0!I am a generic JSON response which wraps a parsed JSON tree. I use DNU magic to obtain a named branch of JSON tree.Instance Variables:	tree	a parsed JSON tree (Dictionary)!!ParsecoJsonResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 15:32'!tree: anObject	tree := anObject! !!ParsecoJsonResponse methodsFor: 'error handling' stamp: 'MilanMimica 8/24/2012 12:13'!doesNotUnderstand: aMessage| node |	aMessage arguments size isZero ifFalse: [ super doesNotUnderstand: aMessage ].	node := tree at: aMessage selector asString ifAbsent: [ super doesNotUnderstand: aMessage ] .	^ node isDictionary		ifTrue: [ ParsecoJsonResponse newFrom: node ]		ifFalse: [ node ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoJsonResponse class	instanceVariableNames: ''!!ParsecoJsonResponse class methodsFor: 'instance creation' stamp: 'MilanMimica 8/21/2012 15:33'!fromString: aString	^ self newFrom: (NeoJSONReader fromString: aString)! !!ParsecoJsonResponse class methodsFor: 'instance creation' stamp: 'MilanMimica 8/21/2012 15:33'!newFrom: aDictionary	^ self new tree: aDictionary! !!ParsecoJsonResponse class methodsFor: 'instance creation' stamp: 'MilanMimica 8/21/2012 15:34'!on: aStream	^ self newFrom: (NeoJSONReader on: aStream) next! !ParsecoJsonResponse subclass: #ParsecoHlrExtendedData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoHlrExtendedData commentStamp: 'MilanMimica 8/24/2012 14:04' prior: 0!I contain very detailed HLR data.!Object subclass: #ParsecoTimeZone	instanceVariableNames: 'id name standardUtcOffset dstOffset dstStartTime dstEndTime countryId'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!countryId	^ countryId! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!countryId: anObject	countryId := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstEndTime	^ dstEndTime! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstEndTime: anObject	dstEndTime := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstOffset	^ dstOffset! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstOffset: anObject	dstOffset := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstStartTime	^ dstStartTime! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!dstStartTime: anObject	dstStartTime := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!id	^ id! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!id: anObject	id := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!name	^ name! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!name: anObject	name := anObject! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!standardUtcOffset	^ standardUtcOffset! !!ParsecoTimeZone methodsFor: 'accessing' stamp: 'MilanMimica 8/23/2012 12:51'!standardUtcOffset: anObject	standardUtcOffset := anObject! !!ParsecoTimeZone methodsFor: 'converting' stamp: 'MilanMimica 8/23/2012 13:00'!asTimeZone| result |	result := TimeZone timeZones detect: [ :each | each offset = standardUtcOffset / 60 ].	^ result ifNil: [ TimeZone offset: standardUtcOffset / 60 name: name abbreviation: '' ]! !Object subclass: #ParsecoHlrRequest	instanceVariableNames: 'address notifyURL clientCorrelator'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:07'!address	^ address! !!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:07'!address: anObject	address := anObject! !!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:08'!clientCorrelator	^ clientCorrelator! !!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:08'!clientCorrelator: anObject	clientCorrelator := anObject! !!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:07'!notifyURL	^ notifyURL! !!ParsecoHlrRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:07'!notifyURL: anObject	notifyURL := anObject! !Object subclass: #ParsecoSmsRequest	instanceVariableNames: 'message senderAddress address clientCorrelator notifyURL senderName callbackData'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!address	^ address! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!address: anObject	address := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!callbackData	^ callbackData! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!callbackData: anObject	callbackData := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!clientCorrelator	^ clientCorrelator! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!clientCorrelator: anObject	clientCorrelator := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!message	^ message! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!message: anObject	message := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!notifyURL	^ notifyURL! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!notifyURL: anObject	notifyURL := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!senderAddress	^ senderAddress! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!senderAddress: anObject	senderAddress := anObject! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!senderName	^ senderName! !!ParsecoSmsRequest methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 16:23'!senderName: anObject	senderName := anObject! !ParsecoJsonResponse subclass: #ParsecoInboundMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoInboundMessage methodsFor: 'accessing' stamp: 'MilanMimica 8/27/2012 16:16'!dateAndTime	^ super dateAndTime! !!ParsecoInboundMessage methodsFor: 'accessing' stamp: 'MilanMimica 8/27/2012 16:16'!destinationAddress	^ super destinationAddress! !!ParsecoInboundMessage methodsFor: 'accessing' stamp: 'MilanMimica 8/27/2012 16:17'!message	^ super message! !!ParsecoInboundMessage methodsFor: 'accessing' stamp: 'MilanMimica 8/27/2012 16:17'!messageId	^ super messageId! !!ParsecoInboundMessage methodsFor: 'accessing' stamp: 'MilanMimica 8/27/2012 16:17'!senderAddress	^ super senderAddress! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoInboundMessage class	instanceVariableNames: ''!!ParsecoInboundMessage class methodsFor: 'instance creation' stamp: 'MilanMimica 8/27/2012 16:21'!readArray: aStream| tree node array |	tree := (NeoJSONReader on: aStream) next.	node := (tree at: 'inboundSMSMessageList' ifAbsent: [ tree ]) at: 'inboundSMSMessage'.	node isArray ifFalse: [ node := Array with: node ].	array := Array new: node size.	node withIndexDo: [ :each :index |		array at: index put: (self newFrom: each)	].	^ array! !Object subclass: #ParsecoLoginResponse	instanceVariableNames: 'verified ibAuthCookie'	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoLoginResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 13:35'!ibAuthCookie	^ ibAuthCookie! !!ParsecoLoginResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 13:35'!ibAuthCookie: anObject	ibAuthCookie := anObject! !!ParsecoLoginResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 13:35'!verified	^ verified! !!ParsecoLoginResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/20/2012 13:35'!verified: anObject	verified := anObject! !ParsecoJsonResponse subclass: #ParsecoHlrResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoHlrResponse commentStamp: 'MilanMimica 8/24/2012 14:39' prior: 0!I am a response to a HRL request. I contain basic information about the cell phone roaming status plus some optional extended hlr data.!!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:00'!address	^ super address! !!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:00'!currentRoaming	^ super currentRoaming! !!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 13:52'!extended	^ ParsecoHlrExtendedData newFrom: (tree at: 'extendedData')! !!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 13:53'!mcc	^ self servingMccMnc mcc! !!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 13:54'!mnc	^ self servingMccMnc mnc! !!ParsecoHlrResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 14:01'!retrievalStatus	^ super retrievalStatus! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParsecoHlrResponse class	instanceVariableNames: ''!!ParsecoHlrResponse class methodsFor: 'instance creation' stamp: 'MilanMimica 8/25/2012 21:32'!readArray: aStream| tree node array |	tree := (NeoJSONReader on: aStream) next.	node := ((tree at: 'terminalRoamingStatusList' ifAbsent: [ tree ]) at: 'roaming').	node isArray ifFalse: [ node := Array with: node ].	array := Array new: node size.	node withIndexDo: [ :each :index |		array at: index put: (self newFrom: each)	].	^ array! !ParsecoJsonResponse subclass: #ParsecoResourceResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoResourceResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 15:04'!resourceId	^ self resourceUrl copyAfterLast: $/! !!ParsecoResourceResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 15:02'!resourceUrl	^ (tree at: 'resourceReference') at: 'resourceURL'! !ParsecoJsonResponse subclass: #ParsecoErrorResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoErrorResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 12:35'!messageId	^ ((tree at: 'requestError') at: 'serviceException') at: 'messageId'! !!ParsecoErrorResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 12:35'!text	^ ((tree at: 'requestError') at: 'serviceException') at: 'text'! !!ParsecoErrorResponse methodsFor: 'accessing' stamp: 'MilanMimica 8/25/2012 21:25'!variables	^ ((tree at: 'requestError') at: 'serviceException') at: 'variables'! !ParsecoJsonResponse subclass: #ParsecoDeliveryBase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoDeliveryBase commentStamp: 'MilanMimica 8/24/2012 12:25' prior: 0!I am an abstract base class for all delivery response classes.Possible statuses are:'DeliveredToTerminal' successful delivery to Terminal.'DeliveryUncertain' delivery status unknown: e.g. because it was handed off to another network.'DeliveryImpossible' unsuccessful delivery; the message could not be delivered before it expired.'MessageWaiting' the message is still queued for delivery. This is a temporary state, pending transition to one of the preceding states.'DeliveredToNetwork' successful delivery to the network enabler responsible for routing the SMS sponsible for routing the SMS!!ParsecoDeliveryBase methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 11:36'!statusFor: destination| pair |	pair := self statuses detect: [ :each | (each at: 'address' ifAbsent: []) = destination ] ifNone: [].	^ pair ifNotNil: [ pair at: 'deliveryStatus' ]! !!ParsecoDeliveryBase methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 11:36'!statuses	self subclassResponsibility! !!ParsecoDeliveryBase methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 12:39'!statusesDo: aTwoArgBlock	^ self statuses do: [ :each |		aTwoArgBlock value: (each at: 'address' ifAbsent: []) value: (each at: 'deliveryStatus' ifAbsent: []) ]! !!ParsecoDeliveryBase methodsFor: 'testing' stamp: 'MilanMimica 8/24/2012 11:36'!allSatisfy: aBlock	^ self statuses allSatisfy: [ :each | aBlock value: (each at: 'deliveryStatus') ]! !!ParsecoDeliveryBase methodsFor: 'testing' stamp: 'MilanMimica 8/24/2012 11:36'!anySatisfy: aBlock	^ self statuses anySatisfy: [ :each | aBlock value: (each at: 'deliveryStatus') ]! !ParsecoDeliveryBase subclass: #ParsecoDeliveryInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoDeliveryInfo commentStamp: 'MilanMimica 8/24/2012 12:25' prior: 0!I am a delivery info boundle. I contain delivery statuses for one or more messages.!!ParsecoDeliveryInfo methodsFor: 'accessing' stamp: 'MilanMimica 8/21/2012 16:09'!statuses	^ self deliveryInfoList deliveryInfo! !ParsecoDeliveryBase subclass: #ParsecoDeliveryNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Parseco-Model'!!ParsecoDeliveryNotification commentStamp: 'MilanMimica 8/24/2012 11:58' prior: 0!I am a delivery notification that is pushed to your HTTP server. I contain a delivery status for one message and optional callback data which was proivded when the message was sent.!!ParsecoDeliveryNotification methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 12:43'!address	^  self statusesDo: [ :address :status | ^ address ]! !!ParsecoDeliveryNotification methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 12:13'!callbackData	^ self deliveryInfoNotification callbackData! !!ParsecoDeliveryNotification methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 12:43'!status	^ self statusesDo: [ :address :status | ^ status ]! !!ParsecoDeliveryNotification methodsFor: 'accessing' stamp: 'MilanMimica 8/24/2012 12:37'!statuses	^ Array with: ((tree at: 'deliveryInfoNotification') at: 'deliveryInfo')! !